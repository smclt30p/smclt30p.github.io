<!DOCTYPE html>
<html>
<head>
	<link href="../../../css/master.css" rel="stylesheet" type="text/css">
	<link rel="shortcut icon" type="image/x-icon" href="img/tux.png" />`
	<title>Console Output - printf vs StringBuilder - Gala's EOF</title>
</head>
<body>
<div class="master">

<div class="post"> <!-- POST START -->
<h3 class="post-title">Console Output - printf vs StringBuilder - 23rd June 2016</h3>			
<pre class="post-body"> <!-- POST MAIN START -->
Well, there goes my daily schedule out of the window. I tried, but I had nothing to report. Bummer. Now, back to topic.

Console Output in Java sucks massive unicorn wang. Really. When you call <b>System.out.printf(String format, Object...items);</b>
you would expect Java to call the C/C++ function from <b>libc</b> called <b>printf()</b> right? WRONG! Java uses string manipulation methods such
as regular expressions to format the regex string and replace the items in order. Now, my argument is that this is slow
and that calling a JNI function could be faster and let <b>libc</b> handle the replacing. Or use a StringBuilder, which could also be faster.

So, lets make some tests. First I tried <b>StringBuilder</b> and here are the results and the code, I did 10 samples:

Code:
<pre class="code">
public class PerfTest {
    public static void main(String[] args) {

        String tag = "12345678";
        String tagSeverity = "ERROR";
        String logTag = "blog_test";
        String message = "Test for blog";

        StringBuilder b = new StringBuilder("[")
                .append(tag)
                .append("] (")
                .append(tagSeverity)
                .append(") ")
                .append(logTag)
                .append(": ")
                .append(message);

        System.out.print(b.toString());

    }
}
</pre>The results:
<pre class="code">
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,02s system 99% cpu 0,112 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 96% cpu 0,117 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,09s user 0,02s system 94% cpu 0,116 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 96% cpu 0,113 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,09s user 0,01s system 100% cpu 0,105 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,09s user 0,02s system 94% cpu 0,116 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 92% cpu 0,119 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,09s user 0,01s system 102% cpu 0,105 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,09s user 0,02s system 95% cpu 0,115 total
* PPerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 100% cpu 0,106 total
</pre>We will take a look at the <b>total</b> time here. Over 10 samples it took <b>StrinbBuilder</b> to do the work an average of 0.112,4 seconds. That is with 
JVM init time. Now, let's try with <b>System.out.printf(String format, Object...items);</b>. Here's the code:
<pre class="code">
public class PerfTest {
    public static void main(String[] args) {
        String tag = "12345678";
        String tagSeverity = "ERROR";
        String logTag = "blog_test";
        String message = "Test for blog";

        System.out.printf("[%s] (%s) %s: %s\n", tag, tagSeverity, logTag, message);
    }
}
</pre>And here are the results:
<pre class="code">
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 102% cpu 0,109 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 101% cpu 0,112 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 101% cpu 0,111 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 96% cpu 0,119 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,02s system 103% cpu 0,109 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,02s system 98% cpu 0,120 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 100% cpu 0,111 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 97% cpu 0,120 total
* PerfTest_jar time java -jar PerfTest.jar
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,02s system 95% cpu 0,123 total
[12345678] (ERROR) blog_test: Test for blog
java -jar PerfTest.jar  0,10s user 0,01s system 99% cpu 0,113 total
</pre>The average time that it took <b>System.out.printf(String format, Object..items);</b> over 10 samples is 0.114,7 seconds. That 2.3 ms slower than 
<b>StringBuilder</b> which is significant for a computer program.
This makes sense. The actual formatting does a class called <b>Formatter</b> so lets take a look at OpenJDK's implementation of that class. 
Lets follow <b>printf()</b>.
<pre class="code">
public PrintStream printf(String format, Object ... args) {
        return format(format, args);
}
</pre>Following further...
<pre class="code">
public PrintStream format(String format, Object ... args) {
        try {
            synchronized (this) {
                ensureOpen();
                if ((formatter == null)
                    || (formatter.locale() != Locale.getDefault()))
                    formatter = new Formatter((Appendable) this);
                formatter.format(Locale.getDefault(), format, args);
            }
        } catch (InterruptedIOException x) {
            Thread.currentThread().interrupt();
        } catch (IOException x) {
            trouble = true;
        }
        return this;
}
</pre>This method aquires the thread lock onto something and does a litle housekeeping with <b>ensureOpen();</b> before calling 
<b>formatter.format(Locale.getDefault(), format, args);</b> Here we see the actual usage of the <b>formatter</b> field, which is an instance of <b>Formatter</b>. 
Lets follow <b>formatter.format(Locale.getDefault, format, args);</b>...
<pre class="code">
public Formatter format(Locale l, String format, Object ... args) {
        ensureOpen();

        // index of last argument referenced
        int last = -1;
        // last ordinary index
        int lasto = -1;

        FormatString[] fsa = parse(format);
        for (int i = 0; i &lt; fsa.length; i++) {
            FormatString fs = fsa[i];
            int index = fs.index();
            try {
                switch (index) {
                case -2:  // fixed string, &quot;%n&quot;, or &quot;%%&quot;
                    fs.print(null, l);
                    break;
                case -1:  // relative index
                    if (last &lt; 0 || (args != null &amp;&amp; last &gt; args.length - 1))
                        throw new MissingFormatArgumentException(fs.toString());
                    fs.print((args == null ? null : args[last]), l);
                    break;
                case 0:  // ordinary index
                    lasto++;
                    last = lasto;
                    if (args != null &amp;&amp; lasto &gt; args.length - 1)
                        throw new MissingFormatArgumentException(fs.toString());
                    fs.print((args == null ? null : args[lasto]), l);
                    break;
                default:  // explicit index
                    last = index - 1;
                    if (args != null &amp;&amp; last &gt; args.length - 1)
                        throw new MissingFormatArgumentException(fs.toString());
                    fs.print((args == null ? null : args[last]), l);
                    break;
                }
            } catch (IOException x) {
                lastException = x;
            }
        }
        return this;
}
</pre>Here, the most interesting statement is <b>FormatString[] fs = parse(format);</b> which returns an array of <b>FormatString</b> objects, which replace the wildcards
with actual values. How does it do that? Regular expressions. Lets trace <b>parse(format);</b>.
<pre class="code">
    private static final String formatSpecifier
        = &quot;%(\\d+\\$)?([-#+ 0,(\\&lt;]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])&quot;;

    private static Pattern fsPattern = Pattern.compile(formatSpecifier);

    private FormatString[] parse(String s) {
        ArrayList&lt;FormatString&gt; al = new ArrayList&lt;&gt;();
        Matcher m = fsPattern.matcher(s);
        for (int i = 0, len = s.length(); i &lt; len; ) {
            if (m.find(i)) {
                // Anything between the start of the string and the beginning
                // of the format specifier is either fixed text or contains
                // an invalid format string.
                if (m.start() != i) {
                    // Make sure we didn't miss any invalid format specifiers
                    checkText(s, i, m.start());
                    // Assume previous characters were fixed text
                    al.add(new FixedString(s.substring(i, m.start())));
                }

                al.add(new FormatSpecifier(m));
                i = m.end();
            } else {
                // No more valid format specifiers.  Check for possible invalid
                // format specifiers.
                checkText(s, i, len);
                // The rest of the string is fixed text
                al.add(new FixedString(s.substring(i)));
                break;
            }
        }
        return al.toArray(new FormatString[al.size()]);
}
</pre>Here we can see the <b>Pattern</b> being compiled and the matcher being run against the <b>format</b> string which we specified in 
<b>System.out.printf(String format, Object...items);</b>. Compiling a pattern and running a regex search is not fast and very expensive, 
that is why it takes cca. 3ms longer for printf to do the work. Now, lets return to the previous code snippet and take a look at 
<b>fs.print((args == null ? null : args[last]), l);</b> ...
<pre class="code">
private interface FormatString {
        int index();
        void print(Object arg, Locale l) throws IOException;
        String toString();
}
</pre>Which leads us to an interface. Lets look up the method implementation inside <b>FormatSpecifier</b>:
<pre class="code">
public void print(Object arg, Locale l) throws IOException {
            if (dt) {
                printDateTime(arg, l);
                return;
            }
            switch(c) {
            case Conversion.DECIMAL_INTEGER:
            case Conversion.OCTAL_INTEGER:
            case Conversion.HEXADECIMAL_INTEGER:
                printInteger(arg, l);
                break;
            case Conversion.SCIENTIFIC:
            case Conversion.GENERAL:
            case Conversion.DECIMAL_FLOAT:
            case Conversion.HEXADECIMAL_FLOAT:
                printFloat(arg, l);
                break;
            case Conversion.CHARACTER:
            case Conversion.CHARACTER_UPPER:
                printCharacter(arg);
                break;
            case Conversion.BOOLEAN:
                printBoolean(arg);
                break;
            case Conversion.STRING:
                printString(arg, l);
                break;
            case Conversion.HASHCODE:
                printHashCode(arg);
                break;
            case Conversion.LINE_SEPARATOR:
                a.append(System.lineSeparator());
                break;
            case Conversion.PERCENT_SIGN:
                a.append('%');
                break;
            default:
                assert false;
            }
        }
</pre>Here is the <b>printf()</b> table beign used to run the format tokens like <b>%s</b> against a list of predefined values. Here is the 
definiton of those values in the nested <b>Conversion</b> class which is inside <b>Formatter</b>:
<pre class="code">
static final char DECIMAL_INTEGER     = 'd';
static final char OCTAL_INTEGER       = 'o';
static final char HEXADECIMAL_INTEGER = 'x';
static final char HEXADECIMAL_INTEGER_UPPER = 'X';
static final char SCIENTIFIC          = 'e';
static final char SCIENTIFIC_UPPER    = 'E';
static final char GENERAL             = 'g';
static final char GENERAL_UPPER       = 'G';
static final char DECIMAL_FLOAT       = 'f';
static final char HEXADECIMAL_FLOAT   = 'a';
static final char HEXADECIMAL_FLOAT_UPPER = 'A';
static final char CHARACTER           = 'c';
static final char CHARACTER_UPPER     = 'C';
static final char DATE_TIME           = 't';
static final char DATE_TIME_UPPER     = 'T';
static final char BOOLEAN             = 'b';
static final char BOOLEAN_UPPER       = 'B';
static final char STRING              = 's';
static final char STRING_UPPER        = 'S';
static final char HASHCODE            = 'h';
static final char HASHCODE_UPPER      = 'H';
static final char LINE_SEPARATOR      = 'n';
static final char PERCENT_SIGN        = '%';
</pre>After determining the format token, it calls specific methods, such as <b>printInteger(arg, l);</b>. Lets follow thats, it's also inside <b>FormatSpecifier</b>.
<pre class="code">
private void printInteger(Object arg, Locale l) throws IOException {
            if (arg == null)
                print("null");
            else if (arg instanceof Byte)
                print(((Byte)arg).byteValue(), l);
            else if (arg instanceof Short)
                print(((Short)arg).shortValue(), l);
            else if (arg instanceof Integer)
                print(((Integer)arg).intValue(), l);
            else if (arg instanceof Long)
                print(((Long)arg).longValue(), l);
            else if (arg instanceof BigInteger)
                print(((BigInteger)arg), l);
            else
                failConversion(c, arg);
        }
</pre>The <b>printInteger( ... );</b> method calls <b>print( ... )</b> inside <b>FormatSpecifier</b>, so lets take a look at that. There is various <b>print()</b> methods in
<b>FormatSpecifier</b>, overloading each other. Let's take a look at one:
<pre class="code">
private void print(long value, Locale l) throws IOException {

            StringBuilder sb = new StringBuilder();

            if (c == Conversion.DECIMAL_INTEGER) {
                boolean neg = value &lt; 0;
                char[] va;
                if (value &lt; 0)
                    va = Long.toString(value, 10).substring(1).toCharArray();
                else
                    va = Long.toString(value, 10).toCharArray();

                // leading sign indicator
                leadingSign(sb, neg);

                // the value
                localizedMagnitude(sb, va, f, adjustWidth(width, f, neg), l);

                // trailing sign indicator
                trailingSign(sb, neg);
            } else if (c == Conversion.OCTAL_INTEGER) {
                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,
                              Flags.PLUS);
                String s = Long.toOctalString(value);
                int len = (f.contains(Flags.ALTERNATE)
                           ? s.length() + 1
                           : s.length());

                // apply ALTERNATE (radix indicator for octal) before ZERO_PAD
                if (f.contains(Flags.ALTERNATE))
                    sb.append('0');
                if (f.contains(Flags.ZERO_PAD))
                    for (int i = 0; i &lt; width - len; i++) sb.append('0');
                sb.append(s);
            } else if (c == Conversion.HEXADECIMAL_INTEGER) {
                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,
                              Flags.PLUS);
                String s = Long.toHexString(value);
                int len = (f.contains(Flags.ALTERNATE)
                           ? s.length() + 2
                           : s.length());

                // apply ALTERNATE (radix indicator for hex) before ZERO_PAD
                if (f.contains(Flags.ALTERNATE))
                    sb.append(f.contains(Flags.UPPERCASE) ? &quot;0X&quot; : &quot;0x&quot;);
                if (f.contains(Flags.ZERO_PAD))
                    for (int i = 0; i &lt; width - len; i++) sb.append('0');
                if (f.contains(Flags.UPPERCASE))
                    s = s.toUpperCase();
                sb.append(s);
            }

            // justify based on width
            a.append(justify(sb.toString()));
        }
</pre>At the end of the method the chunk of text gets added to an <b>Appendable</b>, which is an interface, casted to a <b>PrintStream</b>,
which eventually gets returned to our <b>System.out.printf( ... )</b>. Appending characters to the <b>a</b> <b>Appendable</b> actually prints them to the 
console. That is done with the overloaded <b>print( ... )</b> methods inside <b>FormatSpecifier</b>, and the call <b>a.append(justify(sb.toString()));</b>
does exactly that.

And that is how Java's <b>printf( ... );</b> works.

As you can see, there is a lot of work being done for each <b>%x</b> token. That is why it is 3ms slower, and as more <b>%x</b> tokens get added to the
<b>printf</b> it will only get slower and slower.

Conclusion: Don't use <b>printf( ... )</b> in performance-intensive programs, if you can, and use a <b>StringBuilder</b> 
in combination with <b>System.out.print(String s);</b>.

</pre> <!-- POST TEXT CLOSE -->
<a href="../../../index.html">[ Back to index ]</a>			
<p class="post-footer">----------------------------------------------------------------------------------------------------------------------------------</p>		
</div>	<!-- POST END -->
</div>
</body>
</html>
